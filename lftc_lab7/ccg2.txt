([
State: {
Production: program -> ['START', 'tempDecl', 'END']; dot: 0, 
Production: S0 -> ['program']; dot: 0}
, 
State: {
Production: S0 -> ['program']; dot: 1}
, 
State: {
Production: program -> ['START', 'tempDecl', 'END']; dot: 1, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: declList -> ['declaration']; dot: 0, 
Production: declList -> ['declaration', 'declList']; dot: 0, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: declaration -> ['variableDeclaration']; dot: 0, 
Production: declaration -> ['constDeclaration']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0, 
Production: tempDecl -> ['declList', 'tempDecl']; dot: 0, 
Production: tempDecl -> ['stmt']; dot: 0, 
Production: tempDecl -> ['E']; dot: 0, 
Production: tempDecl -> ['stmtList', 'tempDecl']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0}
, 
State: {
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: declList -> ['declaration']; dot: 0, 
Production: declList -> ['declaration', 'declList']; dot: 0, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: declaration -> ['variableDeclaration']; dot: 0, 
Production: declaration -> ['constDeclaration']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0, 
Production: tempDecl -> ['declList', 'tempDecl']; dot: 0, 
Production: tempDecl -> ['stmt']; dot: 0, 
Production: tempDecl -> ['stmtList', 'tempDecl']; dot: 1, 
Production: tempDecl -> ['E']; dot: 0, 
Production: tempDecl -> ['stmtList', 'tempDecl']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0}
, 
State: {
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: declList -> ['declaration']; dot: 0, 
Production: declList -> ['declaration', 'declList']; dot: 0, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: declaration -> ['variableDeclaration']; dot: 0, 
Production: declaration -> ['constDeclaration']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0, 
Production: tempDecl -> ['declList', 'tempDecl']; dot: 0, 
Production: tempDecl -> ['stmt']; dot: 0, 
Production: tempDecl -> ['declList', 'tempDecl']; dot: 1, 
Production: tempDecl -> ['E']; dot: 0, 
Production: tempDecl -> ['stmtList', 'tempDecl']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0}
, 
State: {
Production: stmtList -> ['stmt']; dot: 1}
, 
State: {
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 1, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: tempDecl -> ['stmt']; dot: 1}
, 
State: {
Production: structStmt -> ['whileStmt']; dot: 1}
, 
State: {
Production: structStmt -> ['ifStmt']; dot: 1}
, 
State: {
Production: declaration -> ['constDeclaration']; dot: 1}
, 
State: {
Production: declList -> ['declaration']; dot: 1}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: declList -> ['declaration', 'declList']; dot: 0, 
Production: declList -> ['declaration', 'declList']; dot: 1, 
Production: declList -> ['declaration']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 0, 
Production: declaration -> ['variableDeclaration']; dot: 0, 
Production: declaration -> ['constDeclaration']; dot: 0}
, 
State: {
Production: stmt -> ['simplStmt']; dot: 1}
, 
State: {
Production: program -> ['START', 'tempDecl', 'END']; dot: 2}
, 
State: {
Production: stmt -> ['structStmt']; dot: 1}
, 
State: {
Production: simplStmt -> ['assignStmt']; dot: 1}
, 
State: {
Production: declaration -> ['variableDeclaration']; dot: 1}
, 
State: {
Production: simplStmt -> ['ioStmt']; dot: 1}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 1, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 1, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 1}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 1}
, 
State: {
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 1}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 1, 
Production: expression -> ['boolean']; dot: 0, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 1}
, 
State: {
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 1}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 1}
, 
State: {
Production: tempDecl -> ['E']; dot: 1}
, 
State: {
Production: tempDecl -> ['stmtList', 'tempDecl']; dot: 2}
, 
State: {
Production: tempDecl -> ['declList', 'tempDecl']; dot: 2}
, 
State: {
Production: stmtList -> ['stmt', 'stmtList']; dot: 2}
, 
State: {
Production: declList -> ['declaration', 'declList']; dot: 2}
, 
State: {
Production: program -> ['START', 'tempDecl', 'END']; dot: 3}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 2}
, 
State: {
Production: relation -> ['=']; dot: 0, 
Production: relation -> ['<']; dot: 0, 
Production: relation -> ['>=']; dot: 0, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 1, 
Production: relation -> ['<=']; dot: 0, 
Production: relation -> ['>']; dot: 0, 
Production: relation -> ['!=']; dot: 0}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 1}
, 
State: {
Production: expression -> ['term', '-', 'expression']; dot: 1}
, 
State: {
Production: expression -> ['term']; dot: 1}
, 
State: {
Production: term -> ['factor', '*', 'term']; dot: 1}
, 
State: {
Production: term -> ['factor', '/', 'term']; dot: 1}
, 
State: {
Production: term -> ['factor', '%', 'term']; dot: 1}
, 
State: {
Production: term -> ['factor']; dot: 1}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 1, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: factor -> ['identifier']; dot: 1}
, 
State: {
Production: factor -> ['integer']; dot: 1}
, 
State: {
Production: expression -> ['boolean']; dot: 1}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 2}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 2}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 2}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 2, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 2}
, 
State: {
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 2}
, 
State: {
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 2, 
Production: stringExp -> ['identifier']; dot: 0, 
Production: stringExp -> ['string']; dot: 0}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 2}
, 
State: {
Production: stmt -> ['structStmt']; dot: 0, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 3, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 2, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: relation -> ['!=']; dot: 1}
, 
State: {
Production: relation -> ['=']; dot: 1}
, 
State: {
Production: relation -> ['>']; dot: 1}
, 
State: {
Production: relation -> ['<']; dot: 1}
, 
State: {
Production: relation -> ['<=']; dot: 1}
, 
State: {
Production: relation -> ['>=']; dot: 1}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 2, 
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: expression -> ['term', '-', 'expression']; dot: 2, 
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 2, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 2, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 2, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: factor -> ['(', 'expression', ')']; dot: 2}
, 
State: {
Production: stmt -> ['structStmt']; dot: 0, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 3, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: type -> ['arrayDecl']; dot: 0, 
Production: type -> ['typeConst']; dot: 0, 
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 0, 
Production: typeConst -> ['int']; dot: 0, 
Production: typeConst -> ['string']; dot: 0, 
Production: typeConst -> ['bool']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 3}
, 
State: {
Production: type -> ['arrayDecl']; dot: 0, 
Production: type -> ['typeConst']; dot: 0, 
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 0, 
Production: typeConst -> ['int']; dot: 0, 
Production: typeConst -> ['string']; dot: 0, 
Production: typeConst -> ['bool']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 3}
, 
State: {
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 3}
, 
State: {
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 3, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 3}
, 
State: {
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 3}
, 
State: {
Production: stringExp -> ['identifier']; dot: 1}
, 
State: {
Production: stringExp -> ['string']; dot: 1}
, 
State: {
Production: type -> ['arrayDecl']; dot: 0, 
Production: type -> ['typeConst']; dot: 0, 
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 0, 
Production: typeConst -> ['int']; dot: 0, 
Production: typeConst -> ['string']; dot: 0, 
Production: typeConst -> ['bool']; dot: 0, 
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 3}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 4}
, 
State: {
Production: condition -> ['expression', 'relation', 'expression']; dot: 3}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 3}
, 
State: {
Production: expression -> ['term', '-', 'expression']; dot: 3}
, 
State: {
Production: term -> ['factor', '*', 'term']; dot: 3}
, 
State: {
Production: term -> ['factor', '/', 'term']; dot: 3}
, 
State: {
Production: term -> ['factor', '%', 'term']; dot: 3}
, 
State: {
Production: factor -> ['(', 'expression', ')']; dot: 3}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 4}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 4}
, 
State: {
Production: type -> ['typeConst']; dot: 1}
, 
State: {
Production: type -> ['arrayDecl']; dot: 1}
, 
State: {
Production: typeConst -> ['string']; dot: 0, 
Production: typeConst -> ['int']; dot: 0, 
Production: typeConst -> ['bool']; dot: 0, 
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 1}
, 
State: {
Production: typeConst -> ['string']; dot: 1}
, 
State: {
Production: typeConst -> ['bool']; dot: 1}
, 
State: {
Production: typeConst -> ['int']; dot: 1}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 4}
, 
State: {
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 4}
, 
State: {
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 4}
, 
State: {
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 4}
, 
State: {
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 4}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 4}
, 
State: {
Production: tempElifStmt -> ['E']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 5, 
Production: tempElifStmt -> ['tempElifStmt', 'elifStmt']; dot: 0}
, 
State: {
Production: tempElifStmt -> ['E']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 5, 
Production: tempElifStmt -> ['tempElifStmt', 'elifStmt']; dot: 0}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 5, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 2}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', ';']; dot: 5}
, 
State: {
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 5}
, 
State: {
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 5}
, 
State: {
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 5}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 5, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 6}
, 
State: {
Production: tempElifStmt -> ['tempElifStmt', 'elifStmt']; dot: 1, 
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 0}
, 
State: {
Production: tempElifStmt -> ['E']; dot: 1}
, 
State: {
Production: elseStmt -> ['else', '{', 'stmtList', '}']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 6}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 6}
, 
State: {
Production: arrayDecl -> ['[', 'typeConst', ']']; dot: 3}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 6}
, 
State: {
Production: tempElifStmt -> ['tempElifStmt', 'elifStmt']; dot: 2}
, 
State: {
Production: expression -> ['term', '+', 'expression']; dot: 0, 
Production: expression -> ['term']; dot: 0, 
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 1, 
Production: expression -> ['term', '-', 'expression']; dot: 0, 
Production: expression -> ['boolean']; dot: 0, 
Production: condition -> ['expression', 'relation', 'expression']; dot: 0, 
Production: term -> ['factor', '*', 'term']; dot: 0, 
Production: term -> ['factor', '/', 'term']; dot: 0, 
Production: term -> ['factor', '%', 'term']; dot: 0, 
Production: term -> ['factor']; dot: 0, 
Production: factor -> ['(', 'expression', ')']; dot: 0, 
Production: factor -> ['identifier']; dot: 0, 
Production: factor -> ['integer']; dot: 0}
, 
State: {
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 7}
, 
State: {
Production: elseStmt -> ['else', '{', 'stmtList', '}']; dot: 1}
, 
State: {
Production: variableDeclaration -> ['var', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 7}
, 
State: {
Production: constDeclaration -> ['let', 'identifier', '#', 'type', '=', 'expression', ';']; dot: 7}
, 
State: {
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 2}
, 
State: {
Production: elseStmt -> ['else', '{', 'stmtList', '}']; dot: 2, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 3, 
Production: stmt -> ['simplStmt']; dot: 0, 
Production: stmt -> ['structStmt']; dot: 0, 
Production: whileStmt -> ['loop', 'condition', '{', 'stmtList', '}']; dot: 0, 
Production: assignStmt -> ['identifier', '=', 'expression', ';']; dot: 0, 
Production: stmtList -> ['stmt']; dot: 0, 
Production: stmtList -> ['stmt', 'stmtList']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt']; dot: 0, 
Production: ifStmt -> ['if', 'condition', '{', 'stmtList', '}', 'tempElifStmt', 'elseStmt']; dot: 0, 
Production: structStmt -> ['ifStmt']; dot: 0, 
Production: structStmt -> ['whileStmt']; dot: 0, 
Production: ioStmt -> ['read', '(', 'identifier', ')', ';']; dot: 0, 
Production: ioStmt -> ['write', '(', 'stringExp', ')', ';']; dot: 0, 
Production: simplStmt -> ['ioStmt']; dot: 0, 
Production: simplStmt -> ['assignStmt']; dot: 0}
, 
State: {
Production: elseStmt -> ['else', '{', 'stmtList', '}']; dot: 3}
, 
State: {
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 4}
, 
State: {
Production: elseStmt -> ['else', '{', 'stmtList', '}']; dot: 4}
, 
State: {
Production: elifStmt -> ['elif', 'condition', '{', 'stmtList', '}']; dot: 5}
], {(0, 'program'): 1, (0, 'START'): 2, (2, 'stmtList'): 3, (2, 'declList'): 4, (2, 'stmt'): 7, (2, 'whileStmt'): 8, (2, 'ifStmt'): 9, (2, 'constDeclaration'): 10, (2, 'declaration'): 12, (2, 'simplStmt'): 13, (2, 'tempDecl'): 14, (2, 'structStmt'): 15, (2, 'assignStmt'): 16, (2, 'variableDeclaration'): 17, (2, 'ioStmt'): 18, (2, 'if'): 20, (2, 'var'): 22, (2, 'identifier'): 23, (2, 'loop'): 24, (2, 'read'): 25, (2, 'write'): 26, (2, 'let'): 27, (2, 'E'): 28, (3, 'stmtList'): 3, (3, 'declList'): 4, (3, 'stmt'): 7, (3, 'whileStmt'): 8, (3, 'ifStmt'): 9, (3, 'constDeclaration'): 10, (3, 'declaration'): 12, (3, 'simplStmt'): 13, (3, 'tempDecl'): 29, (3, 'structStmt'): 15, (3, 'assignStmt'): 16, (3, 'variableDeclaration'): 17, (3, 'ioStmt'): 18, (3, 'if'): 20, (3, 'var'): 22, (3, 'identifier'): 23, (3, 'loop'): 24, (3, 'read'): 25, (3, 'write'): 26, (3, 'let'): 27, (3, 'E'): 28, (4, 'stmtList'): 3, (4, 'declList'): 4, (4, 'stmt'): 7, (4, 'whileStmt'): 8, (4, 'ifStmt'): 9, (4, 'constDeclaration'): 10, (4, 'declaration'): 12, (4, 'simplStmt'): 13, (4, 'tempDecl'): 30, (4, 'structStmt'): 15, (4, 'assignStmt'): 16, (4, 'variableDeclaration'): 17, (4, 'ioStmt'): 18, (4, 'if'): 20, (4, 'var'): 22, (4, 'identifier'): 23, (4, 'loop'): 24, (4, 'read'): 25, (4, 'write'): 26, (4, 'let'): 27, (4, 'E'): 28, (6, 'stmtList'): 31, (6, 'stmt'): 5, (6, 'whileStmt'): 8, (6, 'ifStmt'): 9, (6, 'simplStmt'): 13, (6, 'structStmt'): 15, (6, 'assignStmt'): 16, (6, 'ioStmt'): 18, (6, 'if'): 20, (6, 'identifier'): 23, (6, 'loop'): 24, (6, 'read'): 25, (6, 'write'): 26, (12, 'declList'): 32, (12, 'constDeclaration'): 10, (12, 'declaration'): 11, (12, 'variableDeclaration'): 17, (12, 'var'): 22, (12, 'let'): 27, (14, 'END'): 33, (19, 'condition'): 34, (19, 'expression'): 35, (19, 'term'): 38, (19, 'factor'): 42, (19, '('): 43, (19, 'identifier'): 44, (19, 'integer'): 45, (19, 'boolean'): 46, (20, 'condition'): 47, (20, 'expression'): 35, (20, 'term'): 38, (20, 'factor'): 42, (20, '('): 43, (20, 'identifier'): 44, (20, 'integer'): 45, (20, 'boolean'): 46, (21, 'identifier'): 48, (22, 'identifier'): 49, (23, '='): 50, (24, 'condition'): 51, (24, 'expression'): 35, (24, 'term'): 38, (24, 'factor'): 42, (24, '('): 43, (24, 'identifier'): 44, (24, 'integer'): 45, (24, 'boolean'): 46, (25, '('): 52, (26, '('): 53, (27, 'identifier'): 54, (34, '{'): 55, (35, 'relation'): 56, (35, '!='): 57, (35, '='): 58, (35, '>'): 59, (35, '<'): 60, (35, '<='): 61, (35, '>='): 62, (36, '+'): 63, (37, '-'): 64, (39, '*'): 65, (40, '/'): 66, (41, '%'): 67, (43, 'expression'): 68, (43, 'term'): 38, (43, 'factor'): 42, (43, '('): 43, (43, 'identifier'): 44, (43, 'integer'): 45, (43, 'boolean'): 46, (47, '{'): 69, (48, '#'): 70, (49, '#'): 71, (50, 'expression'): 72, (50, 'term'): 38, (50, 'factor'): 42, (50, '('): 43, (50, 'identifier'): 44, (50, 'integer'): 45, (50, 'boolean'): 46, (51, '{'): 73, (52, 'identifier'): 74, (53, 'stringExp'): 75, (53, 'identifier'): 76, (53, 'string'): 77, (54, '#'): 78, (55, 'stmtList'): 79, (55, 'stmt'): 6, (55, 'whileStmt'): 8, (55, 'ifStmt'): 9, (55, 'simplStmt'): 13, (55, 'structStmt'): 15, (55, 'assignStmt'): 16, (55, 'ioStmt'): 18, (55, 'if'): 20, (55, 'identifier'): 23, (55, 'loop'): 24, (55, 'read'): 25, (55, 'write'): 26, (56, 'expression'): 80, (56, 'term'): 38, (56, 'factor'): 42, (56, '('): 43, (56, 'identifier'): 44, (56, 'integer'): 45, (56, 'boolean'): 46, (63, 'expression'): 81, (63, 'term'): 37, (63, 'factor'): 42, (63, '('): 43, (63, 'identifier'): 44, (63, 'integer'): 45, (63, 'boolean'): 46, (64, 'expression'): 82, (64, 'term'): 37, (64, 'factor'): 42, (64, '('): 43, (64, 'identifier'): 44, (64, 'integer'): 45, (64, 'boolean'): 46, (65, 'term'): 83, (65, 'factor'): 39, (65, '('): 43, (65, 'identifier'): 44, (65, 'integer'): 45, (66, 'term'): 84, (66, 'factor'): 39, (66, '('): 43, (66, 'identifier'): 44, (66, 'integer'): 45, (67, 'term'): 85, (67, 'factor'): 39, (67, '('): 43, (67, 'identifier'): 44, (67, 'integer'): 45, (68, ')'): 86, (69, 'stmtList'): 87, (69, 'stmt'): 6, (69, 'whileStmt'): 8, (69, 'ifStmt'): 9, (69, 'simplStmt'): 13, (69, 'structStmt'): 15, (69, 'assignStmt'): 16, (69, 'ioStmt'): 18, (69, 'if'): 20, (69, 'identifier'): 23, (69, 'loop'): 24, (69, 'read'): 25, (69, 'write'): 26, (70, 'type'): 88, (70, 'typeConst'): 89, (70, 'arrayDecl'): 90, (70, '['): 91, (70, 'string'): 92, (70, 'bool'): 93, (70, 'int'): 94, (71, 'type'): 95, (71, 'typeConst'): 89, (71, 'arrayDecl'): 90, (71, '['): 91, (71, 'string'): 92, (71, 'bool'): 93, (71, 'int'): 94, (72, ';'): 96, (73, 'stmtList'): 97, (73, 'stmt'): 6, (73, 'whileStmt'): 8, (73, 'ifStmt'): 9, (73, 'simplStmt'): 13, (73, 'structStmt'): 15, (73, 'assignStmt'): 16, (73, 'ioStmt'): 18, (73, 'if'): 20, (73, 'identifier'): 23, (73, 'loop'): 24, (73, 'read'): 25, (73, 'write'): 26, (74, ')'): 98, (75, ')'): 99, (78, 'type'): 100, (78, 'typeConst'): 89, (78, 'arrayDecl'): 90, (78, '['): 91, (78, 'string'): 92, (78, 'bool'): 93, (78, 'int'): 94, (79, '}'): 101, (87, '}'): 102, (88, '='): 103, (91, 'typeConst'): 104, (91, 'string'): 92, (91, 'bool'): 93, (91, 'int'): 94, (95, ';'): 105, (97, '}'): 106, (98, ';'): 107, (99, ';'): 108, (100, '='): 109, (101, 'tempElifStmt'): 111, (101, 'E'): 112, (102, 'tempElifStmt'): 111, (102, 'E'): 112, (103, 'expression'): 114, (103, 'term'): 38, (103, 'factor'): 42, (103, '('): 43, (103, 'identifier'): 44, (103, 'integer'): 45, (103, 'boolean'): 46, (104, ']'): 115, (109, 'expression'): 116, (109, 'term'): 38, (109, 'factor'): 42, (109, '('): 43, (109, 'identifier'): 44, (109, 'integer'): 45, (109, 'boolean'): 46, (111, 'elifStmt'): 117, (111, 'elif'): 118, (113, 'elseStmt'): 119, (113, 'else'): 120, (114, ';'): 121, (116, ';'): 122, (118, 'condition'): 123, (118, 'expression'): 35, (118, 'term'): 37, (118, 'factor'): 42, (118, '('): 43, (118, 'identifier'): 44, (118, 'integer'): 45, (118, 'boolean'): 46, (120, '{'): 124, (123, '{'): 125, (124, 'stmtList'): 126, (124, 'stmt'): 6, (124, 'whileStmt'): 8, (124, 'ifStmt'): 9, (124, 'simplStmt'): 13, (124, 'structStmt'): 15, (124, 'assignStmt'): 16, (124, 'ioStmt'): 18, (124, 'if'): 20, (124, 'identifier'): 23, (124, 'loop'): 24, (124, 'read'): 25, (124, 'write'): 26, (125, 'stmtList'): 127, (125, 'stmt'): 6, (125, 'whileStmt'): 8, (125, 'ifStmt'): 9, (125, 'simplStmt'): 13, (125, 'structStmt'): 15, (125, 'assignStmt'): 16, (125, 'ioStmt'): 18, (125, 'if'): 20, (125, 'identifier'): 23, (125, 'loop'): 24, (125, 'read'): 25, (125, 'write'): 26, (126, '}'): 128, (127, '}'): 129})